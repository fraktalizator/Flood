package com.fraktalizator.flood.pathfinding.algorithms

import com.fraktalizator.flood.pathfinding.logic.Direction
import com.fraktalizator.flood.pathfinding.logic.DirectionPath
import com.fraktalizator.flood.pathfinding.logic.IPathfindingAlgorithm
import com.fraktalizator.flood.pathfinding.logic.ImmutableTile
import java.util.stream.Collectors
import kotlin.math.abs
import kotlin.math.min

class FloodPathfinding(
    private val getTileCost: (ImmutableTile) -> Int
) : IPathfindingAlgorithm {

    override fun flood(startTile: ImmutableTile, range: Int): Map<ImmutableTile, Int> {
        val positionAndMoveCosts = hashMapInit(range, startTile)
        val justComputedTiles = ArrayList<ImmutableTile>()
        var justComputedTilesTMP: ArrayList<ImmutableTile>
        justComputedTiles.add(startTile)

        for (n in 0 until range) {
            justComputedTilesTMP = ArrayList()
            for (tile in justComputedTiles) {
                val currentCost = positionAndMoveCosts[tile]!!

                val upTile = ImmutableTile(tile.x() + 0, tile.y() + 1)
                val upTileCost = getTileCost(upTile)

                val rightTile = ImmutableTile(tile.x() + 1, tile.y() + 0)
                val rightTileCost = getTileCost(rightTile)

                val downTile = ImmutableTile(tile.x() + 0, tile.y() - 1)
                val downTileCost = getTileCost(downTile)

                val leftTile = ImmutableTile(tile.x() - 1, tile.y() + 0)
                val leftTileCost = getTileCost(leftTile)


                if (upTileCost + currentCost < positionAndMoveCosts[upTile]!!) {
                    positionAndMoveCosts[upTile] = upTileCost + currentCost
                    justComputedTilesTMP.add(upTile)
                }

                if (rightTileCost + currentCost < positionAndMoveCosts[rightTile]!!) {
                    positionAndMoveCosts[rightTile] = rightTileCost + currentCost
                    justComputedTilesTMP.add(rightTile)
                }


                if (downTileCost + currentCost < positionAndMoveCosts[downTile]!!) {
                    positionAndMoveCosts[downTile] = downTileCost + currentCost
                    justComputedTilesTMP.add(downTile)
                }

                if (leftTileCost + currentCost < positionAndMoveCosts[leftTile]!!) {
                    positionAndMoveCosts[leftTile] = leftTileCost + currentCost
                    justComputedTilesTMP.add(leftTile)
                }
            }
            justComputedTiles.clear()
            justComputedTiles.addAll(justComputedTilesTMP)
            justComputedTilesTMP.clear()
        }
        return positionAndMoveCosts
    }

    /**
     * Returns [DirectionPath] generated by "walking down" approach
     */
    override fun getPath(
        startTile: ImmutableTile,
        endTile: ImmutableTile,
        positionAndMoveCosts: Map<ImmutableTile, Int>
    ): DirectionPath {
        val reversedDirectionList = ArrayList<Direction>()
        var isDestinationReached = false
        var iterationTile: ImmutableTile = endTile

        while (!isDestinationReached) {
            val upTile = iterationTile + Direction.Up.tile
            val rightTile = iterationTile + Direction.Right.tile
            val downTile = iterationTile + Direction.Down.tile
            val leftTile = iterationTile + Direction.Left.tile

            val upTileCost =
                if (positionAndMoveCosts[upTile] == null) 999 else positionAndMoveCosts[upTile]!!
            val rightTileCost =
                if (positionAndMoveCosts[rightTile] == null) 999 else positionAndMoveCosts[rightTile]!!
            val downTileCost =
                if (positionAndMoveCosts[downTile] == null) 999 else positionAndMoveCosts[downTile]!!
            val leftTileCost =
                if (positionAndMoveCosts[leftTile] == null) 999 else positionAndMoveCosts[leftTile]!!


            val minValue = min(min(upTileCost, rightTileCost), min(downTileCost, leftTileCost))

            if (upTileCost == minValue) {
                reversedDirectionList += (Direction.Up)
                iterationTile = upTile
            } else if (rightTileCost == minValue) {
                reversedDirectionList += (Direction.Right)
                iterationTile = rightTile
            } else if (downTileCost == minValue) {
                reversedDirectionList += (Direction.Down)
                iterationTile = downTile
            } else if (leftTileCost == minValue) {
                reversedDirectionList += (Direction.Left)
                iterationTile = leftTile
            }

            if (iterationTile == startTile) {
                isDestinationReached = true
            }
        }
        return DirectionPath.reverse(reversedDirectionList)
    }

    override fun getTilesInRange(startTile: ImmutableTile, range: Int): List<ImmutableTile> {
        return getTilesInRange(startTile, range, flood(startTile, range))
    }

    override fun getTilesInRange(
        startTile: ImmutableTile,
        range: Int,
        positionAndMoveCosts: Map<ImmutableTile, Int>
    ): List<ImmutableTile> {
        return positionAndMoveCosts
            .entries
            .stream()
            .filter { entry -> entry.value <= range }
            .map { entry -> entry.key }
            .collect(Collectors.toList())
    }


    private fun hashMapInit(range: Int, startTile: ImmutableTile): HashMap<ImmutableTile, Int> {
        val positionAndMoveCosts = HashMap<ImmutableTile, Int>()
        for (xCord in range downTo -range) {
            for (yCord in range downTo -range) {
                if (abs(xCord) + abs(yCord) <= range) {
                    val tile = ImmutableTile(
                        startTile.x() + xCord,
                        startTile.y() + yCord
                    )
                    positionAndMoveCosts[tile] = range + 1
                }
            }
        }
        positionAndMoveCosts[startTile] = 0
        return positionAndMoveCosts
    }
}
